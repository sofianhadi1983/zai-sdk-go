// Package chat provides types for the Chat Completions API.
package chat

import "encoding/json"

// Role represents the role of a message author.
type Role string

const (
	// RoleSystem represents a system message.
	RoleSystem Role = "system"
	// RoleUser represents a user message.
	RoleUser Role = "user"
	// RoleAssistant represents an assistant message.
	RoleAssistant Role = "assistant"
	// RoleTool represents a tool/function message.
	RoleTool Role = "tool"
	// RoleFunction represents a function message (deprecated, use RoleTool).
	RoleFunction Role = "function"
)

// Message represents a message in a chat conversation.
type Message struct {
	// Role is the role of the message author.
	Role Role `json:"role"`

	// Content is the content of the message.
	// Can be a string or an array of content parts for multimodal messages.
	Content interface{} `json:"content,omitempty"`

	// Name is an optional name for the message author.
	Name string `json:"name,omitempty"`

	// ToolCalls are the tool calls generated by the model.
	ToolCalls []ToolCall `json:"tool_calls,omitempty"`

	// ToolCallID is the ID of the tool call this message is responding to.
	ToolCallID string `json:"tool_call_id,omitempty"`

	// FunctionCall is the function call generated by the model (deprecated).
	FunctionCall *FunctionCall `json:"function_call,omitempty"`
}

// NewUserMessage creates a new user message with text content.
//
// Example:
//
//	msg := chat.NewUserMessage("Hello, how are you?")
//	messages := []chat.Message{msg}
func NewUserMessage(content string) Message {
	return Message{
		Role:    RoleUser,
		Content: content,
	}
}

// NewSystemMessage creates a new system message.
//
// System messages are used to set the behavior and context
// for the AI assistant.
//
// Example:
//
//	msg := chat.NewSystemMessage("You are a helpful assistant.")
//	messages := []chat.Message{msg}
func NewSystemMessage(content string) Message {
	return Message{
		Role:    RoleSystem,
		Content: content,
	}
}

// NewAssistantMessage creates a new assistant message.
//
// Assistant messages represent previous responses from the AI
// and are used to maintain conversation history.
//
// Example:
//
//	msg := chat.NewAssistantMessage("I'm doing well, thank you!")
//	messages := append(messages, msg)
func NewAssistantMessage(content string) Message {
	return Message{
		Role:    RoleAssistant,
		Content: content,
	}
}

// NewToolMessage creates a new tool response message.
//
// Tool messages are used to provide the result of a function/tool
// call back to the model.
//
// Example:
//
//	// After model requests a tool call with ID "call_123"
//	result := `{"temperature": 72, "condition": "sunny"}`
//	msg := chat.NewToolMessage("call_123", result)
//	messages := append(messages, msg)
func NewToolMessage(toolCallID, content string) Message {
	return Message{
		Role:       RoleTool,
		Content:    content,
		ToolCallID: toolCallID,
	}
}

// ContentPart represents a part of multimodal message content.
type ContentPart struct {
	// Type is the type of content part ("text", "image_url").
	Type string `json:"type"`

	// Text is the text content (when Type is "text").
	Text string `json:"text,omitempty"`

	// ImageURL is the image URL (when Type is "image_url").
	ImageURL *ImageURL `json:"image_url,omitempty"`
}

// ImageURL represents an image URL in a multimodal message.
type ImageURL struct {
	// URL is the URL of the image.
	URL string `json:"url"`

	// Detail is the detail level of the image ("auto", "low", "high").
	Detail string `json:"detail,omitempty"`
}

// NewTextContentPart creates a new text content part.
//
// Used for creating multimodal messages that combine text and images.
//
// Example:
//
//	content := []chat.ContentPart{
//	    chat.NewTextContentPart("What's in this image?"),
//	    chat.NewImageContentPart("https://example.com/image.jpg"),
//	}
//	msg := chat.Message{
//	    Role:    chat.RoleUser,
//	    Content: content,
//	}
func NewTextContentPart(text string) ContentPart {
	return ContentPart{
		Type: "text",
		Text: text,
	}
}

// NewImageContentPart creates a new image content part.
//
// Used for sending images to vision-capable models for analysis.
//
// Example:
//
//	content := []chat.ContentPart{
//	    chat.NewTextContentPart("Describe this image"),
//	    chat.NewImageContentPart("https://example.com/photo.jpg"),
//	}
//	msg := chat.Message{
//	    Role:    chat.RoleUser,
//	    Content: content,
//	}
func NewImageContentPart(url string) ContentPart {
	return ContentPart{
		Type: "image_url",
		ImageURL: &ImageURL{
			URL: url,
		},
	}
}

// ToolCall represents a tool call generated by the model.
type ToolCall struct {
	// ID is the unique identifier for the tool call.
	ID string `json:"id"`

	// Type is the type of tool call (currently only "function").
	Type string `json:"type"`

	// Function is the function call details.
	Function FunctionCall `json:"function"`
}

// FunctionCall represents a function call.
type FunctionCall struct {
	// Name is the name of the function to call.
	Name string `json:"name"`

	// Arguments is the JSON-encoded arguments for the function.
	Arguments string `json:"arguments"`
}

// GetArguments parses the function arguments into the given struct.
//
// This method unmarshals the JSON-encoded arguments from a function
// call into a Go struct for easier access.
//
// Example:
//
//	type WeatherArgs struct {
//	    Location string `json:"location"`
//	    Unit     string `json:"unit"`
//	}
//
//	var args WeatherArgs
//	if err := functionCall.GetArguments(&args); err != nil {
//	    log.Fatal(err)
//	}
//	fmt.Printf("Location: %s, Unit: %s\n", args.Location, args.Unit)
func (fc *FunctionCall) GetArguments(v interface{}) error {
	return json.Unmarshal([]byte(fc.Arguments), v)
}

// Tool represents a tool that can be called by the model.
type Tool struct {
	// Type is the type of tool (currently only "function").
	Type string `json:"type"`

	// Function is the function definition.
	Function ToolFunction `json:"function"`
}

// ToolFunction represents a function tool definition.
type ToolFunction struct {
	// Name is the name of the function.
	Name string `json:"name"`

	// Description is a description of what the function does.
	Description string `json:"description,omitempty"`

	// Parameters is the JSON Schema for the function parameters.
	Parameters interface{} `json:"parameters,omitempty"`
}

// NewFunctionTool creates a new function tool.
//
// Function tools allow the model to call external functions to perform
// tasks or retrieve information.
//
// Example:
//
//	parameters := map[string]interface{}{
//	    "type": "object",
//	    "properties": map[string]interface{}{
//	        "location": map[string]interface{}{
//	            "type":        "string",
//	            "description": "City name, e.g., San Francisco",
//	        },
//	        "unit": map[string]interface{}{
//	            "type": "string",
//	            "enum": []string{"celsius", "fahrenheit"},
//	        },
//	    },
//	    "required": []string{"location"},
//	}
//
//	tool := chat.NewFunctionTool(
//	    "get_weather",
//	    "Get the current weather in a given location",
//	    parameters,
//	)
func NewFunctionTool(name, description string, parameters interface{}) Tool {
	return Tool{
		Type: "function",
		Function: ToolFunction{
			Name:        name,
			Description: description,
			Parameters:  parameters,
		},
	}
}

// ToolChoice represents the tool choice configuration.
type ToolChoice string

const (
	// ToolChoiceNone means the model will not call any tools.
	ToolChoiceNone ToolChoice = "none"

	// ToolChoiceAuto means the model can choose to call tools or not.
	ToolChoiceAuto ToolChoice = "auto"

	// ToolChoiceRequired means the model must call at least one tool.
	ToolChoiceRequired ToolChoice = "required"
)

// ResponseFormat represents the response format configuration.
type ResponseFormat struct {
	// Type is the type of response format ("text" or "json_object").
	Type string `json:"type"`
}

var (
	// ResponseFormatText requests plain text responses.
	ResponseFormatText = ResponseFormat{Type: "text"}

	// ResponseFormatJSON requests JSON object responses.
	ResponseFormatJSON = ResponseFormat{Type: "json_object"}
)
